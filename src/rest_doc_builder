#!/bin/lua

-- @script create documentation from file with rest api, defined by rest_api_builder
-- @see rest_api_builder
-- @return json encoded doumentation in standard output
-- @usage call the script with one argument: name of lua module from which will be created documentation, for example:
-- ```sh
-- ./rest_doc_builder api/test
-- ```
-- @warning loaded module must be without extension! It must be same as module name for `require`
--
local cjson = require("cjson")

local C_VERSION_HEADER_NAME = "Accept-Version"

local rest_doc_builder = {}

local header_builder = {name = nil, required = nil, acceptable_values = nil}

function header_builder.new(header_name)
  return setmetatable({name = header_name}, {__index = header_builder})
end

function header_builder:required(is_required)
  self.required = is_required
  return self
end

function header_builder:accept(values)
  if type(values) == "table" then
    self.acceptable_values = values
  else
    self.acceptable_values = {values}
  end

  return self
end

function rest_doc_builder.new()
  return setmetatable({output = {}}, {__index = rest_doc_builder})
end

function rest_doc_builder:header(header_name)
  return header_builder.new(header_name)
end

function rest_doc_builder:create_endpoint(api_version,
                                          method,
                                          path_signature,
                                          _,
                                          description,
                                          control_headers)
  if self.output[api_version] == nil then
    self.output[api_version] = {}
  end

  if control_headers == nil then
    control_headers = {}
  end

  table.insert(control_headers, self:header(C_VERSION_HEADER_NAME)
                 :required(true):accept(api_version))

  table.insert(self.output[api_version], {
    method = method,
    path_signature = path_signature,
    description = description,
    control_headers = control_headers,
  })
end

function rest_doc_builder:create_endpoint_t(arg_table)
  return self:create_endpoint(arg_table.api_version, arg_table.method,
                              arg_table.path_signature, arg_table.callback,
                              arg_table.description, arg_table.control_headers)
end

function rest_doc_builder:handle_request()
  return self.output
end

local ngx = {
  var = {},
  req = {
    get_method = function()
    end,
  },
  unescape_uri = function()
  end,
}

local process = require
_G.require = function(package_name)
  if package_name == "ngx" then
    return ngx
  elseif package_name == "rest_api_builder" then
    return rest_doc_builder
  else
    local universal_object = {}
    local universal_function = function()
      return universal_object
    end
    -- XXX in case, when before creating api you need upload other modules and call returned objects, then you need
    -- add this calling methods as mehods of `universal_object`, for example:
    -- universal_object.get = universal_function
    -- you don't need add tables, because all getted values from the universal object is other universal object

    return setmetatable(universal_object, {__index = universal_function})
  end
end

local function main()
  local api_file = arg[1]
  if api_file == nil then
    error("you must set name of module for processing as first argument")
  end

  if string.match(api_file, "[.]lua$") then
    -- fix this automaticly
    api_file = string.sub(api_file, 1, -5)
  end

  local documentation = process(api_file)
  print(cjson.encode(documentation))
end

main()
